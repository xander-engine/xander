use proc_macro::TokenStream;
use quote::quote;
use syn::{punctuated::Punctuated, LitInt, Token, parse_macro_input, parse::Parse, Ident};

struct DiceSides(Punctuated<LitInt, Token![,]>);

impl DiceSides {
    fn into_iter(self) -> impl Iterator<Item = LitInt> {
        self.0.into_iter()
    }
}

impl Parse for DiceSides {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self(Punctuated::parse_terminated(input)?))
    }
}

///
/// ## `dice!` Macro
/// Auto-generates implementation of the `Die` trait for
/// multiple sides of die.
/// 
/// ### Syntax
/// `dice!(4, 6, 8, 10, 12, 20, 100)`
/// 
#[proc_macro]
pub fn dice(tokens : TokenStream) -> TokenStream {
    let sides = parse_macro_input!(tokens as DiceSides);

    let dice_impls = sides.into_iter()
        .map(|sides| {
            let ident = Ident::new(&format!("D{}", sides.base10_digits()), sides.span());
            let doc_string = format!("A {}-sided die.", sides.base10_digits());
            quote! {
                #[doc = #doc_string]
                #[doc = "***"]
                #[doc = "ðŸ¤– Autogenerated by [xander_macros::dice]"]
                #[doc = ""]
                pub struct #ident;

                impl Die for #ident {
                    fn sides(&self) -> usize {
                        #sides
                    }
                }

                impl FnOnce<()> for #ident {
                    type Output = Vec<i32>;

                    extern "rust-call" fn call_once(self, _: ()) -> Self::Output {
                        self.roll(None)
                    }
                }

                
                impl FnMut<()> for #ident {
                    extern "rust-call" fn call_mut(&mut self, _: ()) -> Self::Output {
                        self.roll(None)
                    }
                }

                impl Fn<()> for #ident {
                    extern "rust-call" fn call(&self, _: ()) -> Self::Output {
                        self.roll(None)
                    }
                }

                impl<I : Into<Option<usize>>> FnOnce<(I,)> for #ident {
                    type Output = Vec<i32>;

                    extern "rust-call" fn call_once(self, args: (I,)) -> Self::Output {
                        self.roll(args.0)
                    }
                } 

                impl<I : Into<Option<usize>>> FnMut<(I,)> for #ident {
                    extern "rust-call" fn call_mut(&mut self, args: (I,)) -> Self::Output {
                        self.roll(args.0)
                    }
                }
                impl<I : Into<Option<usize>>> Fn<(I,)> for #ident {
                    extern "rust-call" fn call(&self, args: (I,)) -> Self::Output {
                        self.roll(args.0)
                    }
                }
            }
        });

    quote! {
        #(#dice_impls)*
    }.into()
}