use proc_macro::TokenStream;
use quote::quote;
use syn::{punctuated::Punctuated, LitInt, Token, parse_macro_input, parse::Parse, Ident};

struct DiceSides(Punctuated<LitInt, Token![,]>);

impl DiceSides {
    fn into_iter(self) -> impl Iterator<Item = LitInt> {
        self.0.into_iter()
    }
}

impl Parse for DiceSides {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self(Punctuated::parse_terminated(input)?))
    }
}

///
/// ## `dice!` Macro
/// Auto-generates implementation of the `Die` trait for
/// multiple sides of die.
/// 
/// ### Syntax
/// `dice!(4, 6, 8, 10, 12, 20, 100)`
/// 
#[proc_macro]
pub fn dice(tokens : TokenStream) -> TokenStream {
    let sides = parse_macro_input!(tokens as DiceSides);

    let dice_impls = sides.into_iter()
        .map(|sides| {
            let ident = Ident::new(&format!("D{}", sides.base10_digits()), sides.span());
            let doc_string = format!("A {}-sided die.", sides.base10_digits());
            quote! {
                #[doc = #doc_string]
                #[doc = "***"]
                #[doc = "ðŸ¤– Autogenerated by [xander_macros::dice]"]
                #[doc = ""]
                #[derive(Debug, Clone, Copy)]
                pub struct #ident;

                impl Die for #ident {
                    fn sides(&self) -> usize {
                        #sides
                    }
                }

                impl FnOnce<()> for #ident {
                    type Output = Rolls;

                    extern "rust-call" fn call_once(self, _: ()) -> Self::Output {
                        self.roll(1)
                    }
                }

                
                impl FnMut<()> for #ident {
                    extern "rust-call" fn call_mut(&mut self, _: ()) -> Self::Output {
                        self.roll(1)
                    }
                }

                impl Fn<()> for #ident {
                    extern "rust-call" fn call(&self, _: ()) -> Self::Output {
                        self.roll(1)
                    }
                }

                impl FnOnce<(usize,)> for #ident {
                    type Output = Rolls;
                
                    extern "rust-call" fn call_once(self, args: (usize,)) -> Self::Output {
                        self.roll(args.0)
                    }
                } 
                
                impl FnMut<(usize,)> for #ident {
                    extern "rust-call" fn call_mut(&mut self, args: (usize,)) -> Self::Output {
                        self.roll(args.0)
                    }
                }
                
                impl Fn<(usize,)> for #ident {
                    extern "rust-call" fn call(&self, args: (usize,)) -> Self::Output {
                        self.roll(args.0)
                    }
                }

                impl Add<i32> for #ident {
                    type Output = Rolls;
                
                    fn add(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x + rhs)
                    }
                }
                impl Sub<i32> for #ident {
                    type Output = Rolls;
                
                    fn sub(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x - rhs)
                    }
                }
                impl Mul<i32> for #ident {
                    type Output = Rolls;
                
                    fn mul(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x * rhs)
                    }
                }
                impl Div<i32> for #ident {
                    type Output = Rolls;
                
                    fn div(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x / rhs)
                    }
                }

                impl Into<Rolls> for #ident {
                    fn into(self) -> Rolls {
                        self.roll(1)
                    }
                }
            }
        });

    quote! {
        #(#dice_impls)*
    }.into()
}