use proc_macro::TokenStream;
use quote::quote;
use syn::{punctuated::Punctuated, LitInt, Token, parse_macro_input, parse::Parse, Ident, token::Paren, parenthesized, Path};

struct DiceSides(Punctuated<LitInt, Token![,]>);

impl DiceSides {
    fn into_iter(self) -> impl Iterator<Item = LitInt> {
        self.0.into_iter()
    }
}

impl Parse for DiceSides {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self(Punctuated::parse_terminated(input)?))
    }
}

///
/// ## `dice!` Macro
/// Auto-generates implementation of the `Die` trait for
/// multiple sides of die.
/// 
/// ### Syntax
/// `dice!(4, 6, 8, 10, 12, 20, 100)`
/// 
#[proc_macro]
pub fn dice(tokens : TokenStream) -> TokenStream {
    let sides = parse_macro_input!(tokens as DiceSides);

    let dice_impls = sides.into_iter()
        .map(|sides| {
            let ident = Ident::new(&format!("D{}", sides.base10_digits()), sides.span());
            let doc_string = format!("A {}-sided die.", sides.base10_digits());
            quote! {
                #[doc = #doc_string]
                #[doc = "***"]
                #[doc = "ðŸ¤– Autogenerated by [xander_macros::dice]"]
                #[doc = ""]
                #[derive(Debug, Clone, Copy)]
                pub struct #ident;

                impl Die for #ident {
                    fn sides(&self) -> usize {
                        #sides
                    }
                }

                impl FnOnce<()> for #ident {
                    type Output = Rolls;

                    extern "rust-call" fn call_once(self, _: ()) -> Self::Output {
                        self.roll(1)
                    }
                }

                
                impl FnMut<()> for #ident {
                    extern "rust-call" fn call_mut(&mut self, _: ()) -> Self::Output {
                        self.roll(1)
                    }
                }

                impl Fn<()> for #ident {
                    extern "rust-call" fn call(&self, _: ()) -> Self::Output {
                        self.roll(1)
                    }
                }

                impl FnOnce<(usize,)> for #ident {
                    type Output = Rolls;
                
                    extern "rust-call" fn call_once(self, args: (usize,)) -> Self::Output {
                        self.roll(args.0)
                    }
                } 
                
                impl FnMut<(usize,)> for #ident {
                    extern "rust-call" fn call_mut(&mut self, args: (usize,)) -> Self::Output {
                        self.roll(args.0)
                    }
                }
                
                impl Fn<(usize,)> for #ident {
                    extern "rust-call" fn call(&self, args: (usize,)) -> Self::Output {
                        self.roll(args.0)
                    }
                }

                impl Add<i32> for #ident {
                    type Output = Rolls;
                
                    fn add(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x + rhs)
                    }
                }
                impl Sub<i32> for #ident {
                    type Output = Rolls;
                
                    fn sub(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x - rhs)
                    }
                }
                impl Mul<i32> for #ident {
                    type Output = Rolls;
                
                    fn mul(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x * rhs)
                    }
                }
                impl Div<i32> for #ident {
                    type Output = Rolls;
                
                    fn div(self, rhs: i32) -> Self::Output {
                        self.roll(1)
                            .then(|x| x / rhs)
                    }
                }

                impl Into<Rolls> for #ident {
                    fn into(self) -> Rolls {
                        self.roll(1)
                    }
                }
            }
        });

    quote! {
        #(#dice_impls)*
    }.into()
}

struct AbilityList(Punctuated<Ident, Token![,]>);

impl Parse for AbilityList {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self(Punctuated::parse_terminated(input)?))
    }
}

impl AbilityList {
    fn into_iter(self) -> impl Iterator<Item = Ident> {
        self.0.into_iter()
    }
}

///
/// Defines a new ability, implementing all the necessary
/// traits.
/// 
#[proc_macro]
pub fn abilities(tokens : TokenStream) -> TokenStream {
    let idents = parse_macro_input!(tokens as AbilityList);

    let iter = idents
        .into_iter()
        .map(|ident| {
            let id = format!("5E::ABILITY::{}",ident.to_string().to_uppercase());
            quote! {
                #[doc = "ðŸ¤– Autogenerated by [xander_macros::abilities]"]
                #[doc = ""]
                #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
                pub struct #ident;

                impl Ability  for #ident {
                    fn default() -> Self {
                        Self
                    }
                }
                impl Identity for #ident {
                    fn id(&self) -> &'static str {
                        #id
                    }

                    fn __id() -> &'static str {
                        #id
                    }
                }
                impl Save  for #ident {}
                impl Check for #ident {
                    fn base() -> Box<dyn Ability> {
                        Box::new(Self)
                    } 
                }
            }
        });

    quote! {
        #(#iter)*
    }.into()
}

struct AbilitySkills(Ident, Paren, Punctuated<Ident, Token![,]>);

impl Parse for AbilitySkills {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let stream;
        Ok(Self(
            input.parse()?,
            parenthesized!(stream in input),
            stream.parse_terminated(Ident::parse, Token![,])?
        ))
    }
}

impl AbilitySkills {
    fn into_iter(self) -> impl Iterator<Item = Ident> {
        self.2.into_iter()
    }
}



struct Skills(Punctuated<AbilitySkills, Token![,]>);

impl Parse for Skills {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self(
            Punctuated::parse_terminated(input)?
        ))
    }
}

impl Skills {
    fn into_iter(self) -> impl Iterator<Item = AbilitySkills> {
        self.0.into_iter()
    }
}

///
/// Defines new skills, with each based on an ability.
/// 
/// ### Syntax
/// `skills!(BaseAbility(Skill1, Skill2, ...), ...)`
/// 
#[proc_macro]
pub fn skills(tokens : TokenStream) -> TokenStream {
    let abilities = parse_macro_input!(tokens as Skills);

    let iter = abilities.into_iter()
        .flat_map(|ab| {
            let ab_ident = ab.0.clone();
            ab.into_iter()
                .map(move |ref sk| {
                    let ab = &ab_ident;
                    let id = format!("5E::SKILL::{}", sk.to_string().to_uppercase());
                    let doc_string = format!("Base ability: [{}]", ab.to_string());
                    quote! {
                        #[doc = #doc_string]
                        #[doc = "***"]
                        #[doc = "ðŸ¤– Autogenerated by [xander_macros::skills]"]
                        #[doc = ""]
                        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
                        pub struct #sk;

                        impl Identity for #sk {
                            fn id(&self) -> &'static str {
                                #id
                            }

                            fn __id() -> &'static str {
                                #id
                            }
                        }

                        impl Skill for #sk {
                            fn base(&self) -> Box<dyn Ability> {
                                Box::new(#ab)
                            }
                        }

                        impl Check for #sk {
                            fn base() -> Box<dyn Ability> {
                                Box::new(#ab)
                            } 
                        }
                    }
                })
        });

    quote! {
        #(#iter)*
    }.into()
}

#[proc_macro]
pub fn proficiency(tokens : TokenStream) -> TokenStream {

    struct ProfDecl(Ident, Paren, Punctuated<Path, Token![+]>);

    impl Parse for ProfDecl {
        fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
            let inner;
            Ok(Self(input.parse()?, parenthesized!(inner in input), inner.parse_terminated(Path::parse, Token![+])?))
        }
    }

    let prof = parse_macro_input!(tokens as ProfDecl);

    let ident = &prof.0;
    let traits = prof.2.into_iter().collect::<Vec<_>>();

    let id = format!("5E::PROFICIENCY::{}", ident.to_string().to_uppercase());
    
    quote! {
        #[derive(std::fmt::Debug, core::hash::Hash, core::cmp::PartialEq, core::cmp::Eq)]
            pub struct #ident<T: #(#traits)+* + std::fmt::Debug + core::hash::Hash + core::cmp::Eq>(pub T);

            impl<T: #(#traits)+* + std::fmt::Debug + core::hash::Hash + core::cmp::Eq> Proficiency<T> for #ident<T> {
                fn value(&self) -> &T {
                    &self.0
                }
            }

            impl<T: #(#traits)+* + std::fmt::Debug + core::hash::Hash + core::cmp::Eq> Identity for #ident<T> {
                fn id(&self) -> &'static str { #id }
                fn __id()    -> &'static str
                    where Self : Sized { #id }
            }

    }.into()
}